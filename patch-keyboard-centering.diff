*** a/app/page.tsx
--- b/app/page.tsx
@@
 import Header from '@/components/Header'
 import Grid from '@/components/Grid'
 import ClueBar from '@/components/ClueBar'
 import ClueList from '@/components/ClueList'
 import { generateDaily } from '@/lib/puzzle'
 import { loadDemoFromFile } from '@/lib/puzzle'
 import { yyyyMmDd } from '@/utils/date'
-import { useMemo, useState, useEffect, useRef } from 'react'
+import { useMemo, useState, useEffect, useRef } from 'react'
 
 export default function Page() {
   const [demo, setDemo] = useState<boolean | null>(null)
   const [puzzle, setPuzzle] = useState<any | null>(null)
   const [cells, setCells] = useState<any[]>([])
   const [active, setActive] = useState<{ number: number | null, dir: 'across' | 'down' }>({ number: null, dir: 'across' })
   const [jump, setJump] = useState<{ number: number, dir: 'across' | 'down', nonce: number } | undefined>()
   const [clueBarH, setClueBarH] = useState(0)
   const [kbOpen, setKbOpen] = useState(false)
   const [scale, setScale] = useState(1)
 
   const gridOuterRef = useRef<HTMLDivElement>(null)
   const gridInnerRef = useRef<HTMLDivElement>(null) // for measuring natural height
@@
   // Detect keyboard via VisualViewport inset
   useEffect(() => {
     const vv = (window as any).visualViewport
     if (!vv) return
     const onResize = () => {
       const inset = Math.max(0, window.innerHeight - vv.height - vv.offsetTop)
       setKbOpen(inset > 0)
       // recompute scale on each change
       requestAnimationFrame(() => {
         const inner = gridInnerRef.current
         if (!inner) return
         const naturalHeight = inner.offsetHeight // unscaled height of the grid
         // available height inside viewport
         const available = vv.height - clueBarH - 12 /* breathing room */
         const s = Math.min(1, Math.max(0.6, available / naturalHeight)) // cap between 0.6 and 1
         setScale(s)
       })
     }
     onResize()
     vv.addEventListener('resize', onResize)
     vv.addEventListener('scroll', onResize)
     return () => {
       vv.removeEventListener('resize', onResize)
       vv.removeEventListener('scroll', onResize)
     }
   }, [clueBarH])
@@
   return (
     <main className="pb-28" style={{ paddingBottom: clueBarH + 16 }}>
       {/* Hide header when keyboard is open to buy vertical room */}
       {!kbOpen && (
         <Header title={puzzle.title ?? 'Today'} subtitle={puzzle.theme ?? ''} />
       )}
 
       {/* Scale-to-fit wrapper */}
-      <div ref={gridOuterRef}
-        style={{ transform: `scale(${scale})`, transformOrigin: 'top center' }}>
-        <div ref={gridInnerRef}>
-          <Grid cells={cells} setCells={setCells} onActiveChange={setActive} jump={jump} />
-        </div>
-      </div>
+      <div
+        ref={gridOuterRef}
+        style={{
+          transform: `scale(${scale})`,
+          transformOrigin: 'top center',
+          display: 'flex',
+          justifyContent: 'center',
+        }}
+      >
+        <div ref={gridInnerRef} style={{ display: 'inline-block' }}>
+          <Grid
+            cells={cells}
+            setCells={setCells}
+            onActiveChange={setActive}
+            jump={jump}
+            kbOpen={kbOpen}
+          />
+        </div>
+      </div>
@@
-      <ClueBar text={clueText} onHeightChange={setClueBarH} />
+      <ClueBar text={clueText} onHeightChange={setClueBarH} />
     </main>
   )
 }
*** a/components/Grid.tsx
--- b/components/Grid.tsx
@@
-export default function Grid({cells, setCells, onActiveChange, jump}:{cells:Cell[]; setCells:(cells:Cell[])=>void; onActiveChange?:(info:{number:number|null, dir:'across'|'down'})=>void; jump?:{number:number, dir:'across'|'down', nonce:number}}){
+export default function Grid({
+  cells, setCells, onActiveChange, jump, kbOpen
+}:{cells:Cell[]; setCells:(cells:Cell[])=>void; onActiveChange?:(info:{number:number|null, dir:'across'|'down'})=>void; jump?:{number:number, dir:'across'|'down', nonce:number}; kbOpen?: boolean }){
@@
   useEffect(()=>{
     const idx = coordsToIndex(cursor.row, cursor.col, SIZE)
     const el = inputsRef.current[idx]
-    if (el && !cells[idx].isBlack) el.focus({ preventScroll: true })
+    if (el && !cells[idx].isBlack) {
+      el.focus({ preventScroll: true })
+      // keep active cell visible even when scaled/keyboard open
+      setTimeout(()=> el.scrollIntoView({ block: 'center', inline: 'center', behavior: 'smooth' }), 0)
+    }
   }, [cursor])
@@
   return (
     <div>
       <div className="px-4 pt-3 pb-2 text-sm text-gray-500 flex items-center justify-between">
         <div>Clue #{activeNumber ?? '—'} • {dir.toUpperCase()}</div>
-        <button className="underline" onClick={toggleDir}>Toggle</button>
+        {!kbOpen && (
+          <button className="underline" onClick={toggleDir}>Toggle</button>
+        )}
       </div>
@@
-        <div className="mt-2 flex justify-end px-1">
-          <button onClick={checkWord} className="px-3 py-1.5 text-sm border rounded-md border-gray-300 dark:border-gray-700">Check</button>
-        </div>
+        {!kbOpen && (
+          <div className="mt-2 flex justify-end px-1">
+            <button onClick={checkWord} className="px-3 py-1.5 text-sm border rounded-md border-gray-300 dark:border-gray-700">Check</button>
+          </div>
+        )}
       </div>
-      <div className="px-4 text-sm text-gray-500 mt-2">Tip: tap a cell to type • tap again to switch direction</div>
+      {!kbOpen && (
+        <div className="px-4 text-sm text-gray-500 mt-2">Tip: tap a cell to type • tap again to switch direction</div>
+      )}
     </div>
   )
 }
*** a/components/ClueBar.tsx
--- b/components/ClueBar.tsx
@@
-'use client'
-import { useEffect, useState } from 'react'
-export default function ClueBar({ text }: { text: string }) {
-  const [bottom, setBottom] = useState(0)
-  useEffect(()=>{
-    const vv = (window as any).visualViewport
-    if (!vv) return
-    const update=()=>{
-      const inset = Math.max(0, window.innerHeight - vv.height - vv.offsetTop)
-      setBottom(inset)
-    }
-    update()
-    vv.addEventListener('resize', update)
-    vv.addEventListener('scroll', update)
-    return ()=>{
-      vv.removeEventListener('resize', update)
-      vv.removeEventListener('scroll', update)
-    }
-  }, [])
-  return (
-    <div style={{ bottom }} className="fixed left-0 right-0 z-20 bg-white/95 dark:bg-black/80 border-t border-gray-200 dark:border-gray-800 px-3 py-2">
-      <div className="max-w-md mx-auto truncate text-sm">{text || ' '}</div>
-    </div>
-  )
-}
+'use client'
+import { useEffect, useLayoutEffect, useRef, useState } from 'react'
+export default function ClueBar({ text, onHeightChange }:{ text: string; onHeightChange?: (px:number)=>void }){
+  const [bottom, setBottom] = useState(0)
+  const [maxH, setMaxH] = useState<number>(120)
+  const wrapRef = useRef<HTMLDivElement>(null)
+
+  useEffect(()=>{
+    const vv = (window as any).visualViewport
+    if (!vv) return
+    const update=()=>{
+      const inset = Math.max(0, window.innerHeight - vv.height - vv.offsetTop)
+      setBottom(inset)
+      setMaxH(Math.floor(vv.height * 0.42))
+    }
+    update()
+    vv.addEventListener('resize', update)
+    vv.addEventListener('scroll', update)
+    return ()=>{
+      vv.removeEventListener('resize', update)
+      vv.removeEventListener('scroll', update)
+    }
+  }, [])
+
+  useLayoutEffect(()=>{
+    const el = wrapRef.current
+    if (!el) return
+    const ro = new ResizeObserver(()=> onHeightChange?.(el.getBoundingClientRect().height))
+    ro.observe(el)
+    return ()=> ro.disconnect()
+  }, [onHeightChange, text])
+
+  return (
+    <div style={{ bottom }} className="fixed left-0 right-0 z-20 border-t border-gray-200 dark:border-gray-800 bg-white/95 dark:bg-black/80">
+      <div ref={wrapRef} style={{ maxHeight: maxH }} className="px-3 py-2 max-w-md mx-auto overflow-y-auto [scrollbar-width:none]">
+        <div className="text-sm leading-snug whitespace-pre-wrap">{text || ' '}</div>
+      </div>
+      <div className="h-[env(safe-area-inset-bottom)]" />
+    </div>
+  )
+}
*** a/lib/puzzle.ts
--- b/lib/puzzle.ts
@@
 export async function loadDemoFromFile(): Promise<Puzzle> {
   const url = `/demo-15x15.json?ts=${Date.now()}`; // cache-buster
   const res = await fetch(url, { cache: 'no-store' });
   if (!res.ok) throw new Error('demo-15x15.json not found');
-  
-  const data = await res.json();
-  console.log('Loaded puzzle:', data.title);
-
-  if (!data.cells || !Array.isArray(data.cells) || data.cells.length !== 225) {
+  const raw = await res.json();
+  console.log('Loaded puzzle:', raw.title);
+  if (!raw.cells || !Array.isArray(raw.cells) || raw.cells.length !== 225) {
     throw new Error('Invalid demo puzzle format');
   }
-  return data as Puzzle;
+  // normalize clue text (handle [id, 'Text'] and stringified variants)
+  const coerceClueText = (t: any): string => {
+    if (Array.isArray(t)) return String(t[1] ?? t[0] ?? '')
+    if (t && typeof t === 'object' && 'clue' in t) return String((t as any).clue ?? '')
+    if (typeof t === 'string') {
+      const m = t.match(/^\\s*\\[\\s*\\d+\\s*,\\s*["'](.+?)["']\\s*\\]\\s*$/)
+      if (m) return m[1]
+      return t
+    }
+    return ''
+  }
+  const normalize = (arr:any[]) => (arr ?? []).map((c:any)=>({
+    number: Number(c.number),
+    text: coerceClueText(c.text),
+    length: Number(c.length),
+  }))
+  return {
+    id: String(raw.id ?? 'demo'),
+    title: String(raw.title ?? 'Imported Puzzle'),
+    theme: String(raw.theme ?? ''),
+    across: normalize(raw.across),
+    down: normalize(raw.down),
+    cells: raw.cells as Cell[],
+  };
 }
